#' Generate an encoding key which is used for encoding and decoding strings to pass the R parser
#'
#' @return A list containing the encoding key, with 'input' specifying the characters to be encoded
#' and 'output' specifying their corresponding encoded values.
#' @noRd
.getEncodeKey <- function() {
  encode_list <- list(
    input = c("list", "(", ")", "\"", ",", " ", "c", ":", "!", "&", "|"),
    output = c("$LIST$", "$LB$", "$RB$", "$QUOTE$", "$COMMA$", "$SPACE$", "$C$", "$COLON$", "$EXCL$", "$AND$", "$OR$")
  )
  return(encode_list)
}

#' Remove List
#'
#' This function removes the 'list(' portion from a string.
#'
#' @param string A string containing the characters 'list('.
#' @return The string with 'list(' removed.
#' @importFrom stringr str_replace_all str_sub
#' @noRd
.remove_list <- function(string) {
  string %>%
    str_replace_all(pattern = fixed("list("), replacement = "") %>%
    str_sub(end = -2)
}

#' Converts expressions to a string and remove the 'list(' portion.
#'
#' @param expr The expression to be converted.
#' @return The formatted arguments as a string.
#' @noRd
.format_args_as_string <- function(expr) {
  args_as_string <- quo_text(expr) ## Convert them to a string
  neat_args_as_string <- .remove_list(args_as_string)
  return(neat_args_as_string)
}

#' Encode a string using the provided encoding key.
#'
#' @param input_string The string to be encoded.
#' @param encode_key The encoding key generated by '.getEncodeKey()'.
#' @return The encoded string.
#' @importFrom stringr str_replace_all fixed
#' @noRd
.encode_tidy_eval <- function(input_string, encode_key) {
  encode_vec <- setNames(encode_key$output, encode_key$input)
  output_string <- str_replace_all(input_string, fixed(encode_vec))
}

#' Check if the functions used in tidy evaluation are permitted.
#'
#' @param args_as_string The string representation of the arguments.
#' @importFrom cli cli_abort
#' @details To avoid users attempting to maliciously pass functions to the servervia the tidy_select
#' argument, a regex is used to first extract all functions from the string by identifying any characters
#' with the format 'name('. These are then checked against permitted arguments, which are selection
#' helpers described in the ?select documentation.#'
#' @noRd
.check_function_names <- function(args_as_string){

  permitted_tidy_select <- c("everything", "last_col", "group_cols", "starts_with", "ends_with", "contains",
                             "matches", "num_range", "all_of", "any_of", "where")

  function_names <- str_extract_all(args_as_string, "\\w+(?=\\()", simplify = T)
  any_banned_functions <- function_names[!function_names %in% permitted_tidy_select]
  if(length(any_banned_functions) > 0) {
    cli_abort(
      c(
        "`tidy_select` must only contain Tidyverse select functions",
        "x" = "You have included the following unpermitted function(s): '{any_banned_functions}'",
        "Search ?select for more information"
      )
    )
  }
}

#' Check if the length of variable names in tidy evaluation exceeds a nfilter.string threshold.
#'
#' @param args_as_string The string representation of the arguments.
#' @param nfilter.string The maximum length of variable names allowed.
#' @importFrom cli cli_abort
#' @details To check users are not passing variable names which are too long, first a regex extracts
#' variable names from the list passed to `tidy_select`. It then checks the lengths of these against
#' the value passed to nfilter.string.#'
#' @noRd
.check_variable_length <- function(args_as_string, nfilter.string){
  variable_names <- str_extract_all(args_as_string, "\\b\\w+\\b(?!\\()", simplify = T)
  variable_lengths <- variable_names %>% map_int(str_length)
  over_filter_thresh <- variable_lengths %>% map_lgl(~. > nfilter.string)
  too_long <- variable_names[over_filter_thresh]

  if(length(too_long) > 0 ){
    cli_abort(
      c(
        "The maximum length of columns specified in `tidy_select` is {nfilter.string} characters.",
        "x" = "Detected {length(too_long)} variable{?s} longer than this: {too_long}")
    )
  }
}

#' Checks both for length of variable names and names of functions passed to `tidy_args`
#'
#' @param args_as_string The string representation of the arguments.
#' @param nfilter.string The maximum length of variable names allowed.
#' @noRd
.tidy_disclosure_checks <- function(args_as_string, nfilter.string){
  .check_function_names(args_as_string)
  .check_variable_length(args_as_string, nfilter.string)
}
